/*
 * Copyright (c) 2025 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://edgeimpulse.com/legal/terms-of-service) or Enterprise Terms of
 * Service (https://edgeimpulse.com/legal/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 28.11.2025 16:32:39

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#define STRINGIZE(x) #x
#define STRINGIZE_VALUE_OF(x) STRINGIZE(x)

#if defined (__GNUC__)  /* GNU compiler */
#define ALIGN(X) __attribute__((aligned(X)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (_MSC_VER)
#define ALIGN(X) __declspec(align(X))
#elif defined (__TASKING__) /* TASKING Compiler */
#define ALIGN(X) __align(X)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ARMCC_VERSION) /* Arm Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ICCARM__) /* IAR Compiler */
#define ALIGN(x) __attribute__((aligned(x)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__clang__) /* LLVM/Clang Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#endif

#if defined(EI_MODEL_SECTION) && (defined(__GNUC__) || defined(__clang__))
#define MODEL_SECTION(X) __attribute__((section(STRINGIZE_VALUE_OF(X))))
#else
#define MODEL_SECTION(X)
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 10
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 20
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 11680;
#else
constexpr int kTensorArenaSize = 10656;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
#if defined (EI_TENSOR_ARENA_LOCATION)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) DEFINE_SECTION(STRINGIZE_VALUE_OF(EI_TENSOR_ARENA_LOCATION));
#else
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#endif
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_DEPTHWISE_CONV_2D, OP_MEAN, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,637 } };
const TfArray<1, float> quant0_scale = { 1, { 0.044706642627716064, } };
const TfArray<1, int> quant0_zero = { 1, { -15 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data1[4] = { 1, 49, 13, 1, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(8) int32_t tensor_data2[2] = { 1, 2, };
const TfArray<1, int> tensor_dimension2 = { 1, { 2 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data3[7] = { 256, -1092, 250, 283, -1009, 695, -242, };
const TfArray<1, int> tensor_dimension3 = { 1, { 7 } };
const TfArray<1, float> quant3_scale = { 1, { 0.00021276237384881824, } };
const TfArray<1, int> quant3_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant3 = { (TfLiteFloatArray*)&quant3_scale, (TfLiteIntArray*)&quant3_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data4[7*32] = { 
  35, 67, -36, -103, 28, -10, -15, -127, 69, 3, -2, 33, 84, -79, 36, -97, -52, -44, -40, -52, 32, -95, -61, -39, 55, -88, -75, -34, -122, 39, -46, -99, 
  -73, -47, -13, 68, 4, -70, -67, 23, -62, 45, -25, -76, -24, -93, 25, 53, 48, -2, 17, -64, -96, -59, 46, 34, -73, -8, 28, -40, 35, -73, -85, 55, 
  22, 10, -106, -69, 39, 10, -9, -48, -74, 54, -23, 24, -86, -53, -87, -32, 35, 44, 47, -52, 10, -80, -31, 22, 53, -79, 18, -20, -53, 28, -3, -66, 
  30, 35, -53, -56, 37, 8, -33, 27, -29, -81, -19, -92, -34, -44, 40, 60, 40, -41, -52, -54, 28, -19, -89, -20, -33, -65, -21, 68, 13, 35, -52, -68, 
  39, -55, -19, -36, -78, -66, 14, 26, -64, -16, -29, -4, 11, 38, -42, -41, -67, 35, 62, -20, 25, 73, -23, -74, -59, 34, -94, 38, 39, -66, -2, 18, 
  -29, -95, 60, 8, 44, 48, -14, -77, -59, -60, 68, -45, -10, 32, -88, -48, -82, 37, 7, 61, -77, -8, -42, 49, -74, 0, 33, -59, -61, 38, 60, -72, 
  -51, 39, 54, 49, -47, 1, 68, -20, 53, 25, 9, 26, 61, -25, 37, 32, 16, -50, -32, 48, -47, 47, 46, -37, 19, 65, -45, -30, 23, -40, 54, 29, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 7,32 } };
const TfArray<1, float> quant4_scale = { 1, { 0.012062166817486286, } };
const TfLiteAffineQuantization quant4 = { (TfLiteFloatArray*)&quant4_scale, (TfLiteIntArray*)&g0::quant3_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data5[32] = { 701, -2530, -2299, -4329, 314, -377, -969, -464, -4261, -704, -568, -203, -3966, 252, -4909, -2434, -942, 1957, 1410, -1821, 688, -493, -3123, -134, -557, -1661, 760, 642, -1894, 254, -473, -2291, };
const TfArray<1, int> tensor_dimension5 = { 1, { 32 } };
const TfArray<32, float> quant5_scale = { 32, { 0.00082211347762495279, 0.00053885939996689558, 0.00069843052187934518, 0.00048955040983855724, 0.00060521712293848395, 0.00055162078933790326, 0.00046262910473160446, 0.0006608869880437851, 0.00057662330800667405, 0.0008271561237052083, 0.00094233627896755934, 0.0006996018928475678, 0.00060921860858798027, 0.0010075155878439546, 0.0004877012106589973, 0.00063699734164401889, 0.00062945828540250659, 0.00071803294122219086, 0.00080812984379008412, 0.00054724706569686532, 0.00069193926174193621, 0.00072063767584040761, 0.00045405427226796746, 0.00071577832568436861, 0.00068920577177777886, 0.00045661471085622907, 0.00058868684573099017, 0.00059255055384710431, 0.00058524601627141237, 0.00065769895445555449, 0.00051680294563993812, 0.00065828615333884954, } };
const TfArray<32, int> quant5_zero = { 32, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant5 = { (TfLiteFloatArray*)&quant5_scale, (TfLiteIntArray*)&quant5_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data6[32*1*1*32] = { 
  /* [0][0][][] */ -6,18,-31,-9,6,66,-28,-27,32,-19,-18,-45,89,-11,44,45,-18,-16,-10,-12,0,12,-16,-9,-51,-14,-15,-3,-2,-34,127,-33, 
  /* [1][0][][] */ 115,7,127,-66,34,12,84,-38,74,17,-49,-34,92,8,68,15,-118,-12,-24,104,49,-24,36,-20,-32,10,47,92,-64,65,-63,-35, 
  /* [2][0][][] */ 10,-15,-29,-53,41,-38,7,-36,52,33,41,23,-47,70,-9,-33,-69,13,21,49,2,24,-5,67,127,45,84,24,-60,73,-68,37, 
  /* [3][0][][] */ 61,-16,73,69,36,-92,57,102,7,49,-37,66,-109,-1,5,-26,70,31,127,36,12,-29,108,90,109,36,34,51,29,83,-98,36, 
  /* [4][0][][] */ -94,-2,12,24,-1,44,-2,-50,-33,-53,15,26,72,-57,51,43,65,-29,71,-11,-29,127,-40,-40,33,-32,-28,-4,-39,2,-57,-41, 
  /* [5][0][][] */ -66,-18,11,-92,50,-29,-55,-121,-33,-20,-12,37,-35,36,53,13,-104,32,67,-11,-13,121,-55,32,116,112,42,66,-127,49,-121,-5, 
  /* [6][0][][] */ 93,8,66,-97,73,-59,-1,-7,127,15,-125,-124,-103,105,27,-16,-123,66,-33,91,67,-55,-44,27,-35,112,117,51,-121,105,-54,-52, 
  /* [7][0][][] */ -22,83,8,45,35,-17,-36,31,3,92,-34,-17,44,12,-40,-94,109,127,33,-23,-99,-52,81,33,2,54,-29,-86,28,-5,115,12, 
  /* [8][0][][] */ 127,-8,101,-67,23,-19,93,-30,59,-23,29,38,40,38,13,-37,-108,-28,-13,121,100,-44,-30,46,12,-29,81,110,-57,51,-49,-2, 
  /* [9][0][][] */ 20,-110,73,38,45,-16,40,105,-40,-15,-89,-37,-101,-41,89,127,37,-41,29,24,56,-28,42,-14,9,-11,14,-4,36,42,-21,-41, 
  /* [10][0][][] */ -47,-19,14,-15,7,9,-15,-33,2,25,34,-2,-5,16,-23,-9,-39,-32,39,5,-9,37,-57,20,127,21,-13,-1,-37,22,-32,4, 
  /* [11][0][][] */ 53,-71,18,-60,39,37,11,-6,88,-44,-63,-111,-43,6,59,87,-72,-36,-26,46,127,-30,-38,-17,-12,18,61,62,-52,101,-14,-45, 
  /* [12][0][][] */ 94,-12,33,-52,-4,-15,75,-41,48,3,63,45,29,49,-21,-39,-102,-43,-44,127,97,-25,21,64,52,-45,71,80,-31,61,-16,44, 
  /* [13][0][][] */ -46,-6,-40,-26,23,-8,-32,-42,0,49,17,-25,-18,59,-43,-18,-16,-14,7,2,-8,31,-49,-4,64,36,-6,-44,-23,-15,127,7, 
  /* [14][0][][] */ 116,66,86,-61,19,-58,83,-10,53,44,-18,43,109,37,-16,-89,-9,48,75,127,7,-41,72,73,3,19,94,57,-26,72,-81,92, 
  /* [15][0][][] */ 22,76,53,30,70,-40,-8,6,-14,74,-39,45,19,25,38,-78,67,127,102,-20,-70,-27,108,50,-11,67,38,2,26,30,-68,-1, 
  /* [16][0][][] */ 9,-12,37,51,30,-11,16,46,-71,15,-79,1,-24,-22,119,55,127,106,52,-1,-62,-27,63,19,-14,46,14,-33,16,22,-61,-25, 
  /* [17][0][][] */ -71,-40,-84,46,34,-3,-66,5,-46,-98,-61,-64,-60,-15,55,89,61,-36,3,-20,14,47,27,-47,32,-7,-22,-67,-2,-31,127,-42, 
  /* [18][0][][] */ -48,-63,-83,47,25,-13,-48,28,-32,-41,-54,-41,-71,-18,62,94,71,-35,-17,4,19,1,5,-30,-16,-12,-4,-47,25,-26,127,12, 
  /* [19][0][][] */ 21,4,-19,-87,69,-47,-14,-46,70,18,-9,-66,-81,103,-6,-28,-103,29,42,41,16,42,-47,68,127,70,92,7,-106,115,-70,-20, 
  /* [20][0][][] */ 0,39,-69,-24,5,79,-15,-47,73,10,-37,-72,126,4,28,40,-14,-12,-36,7,2,-38,-33,8,-43,-4,-30,-6,9,-26,127,-7, 
  /* [21][0][][] */ 38,36,-56,-56,81,-53,-20,-35,69,34,-55,-77,-47,104,7,-43,-80,70,-39,38,11,-47,23,42,-7,82,93,-1,-56,36,127,2, 
  /* [22][0][][] */ 37,-57,74,-13,66,-64,64,77,7,48,-31,5,-127,35,38,28,46,33,74,76,37,-48,99,46,27,41,96,28,33,57,-72,-10, 
  /* [23][0][][] */ -78,-41,-9,43,12,3,-16,13,-61,-43,26,26,-44,-45,3,55,127,-36,70,-32,-1,81,4,-5,96,-13,-47,-53,-21,-5,-39,-12, 
  /* [24][0][][] */ 48,-83,43,-40,2,48,48,12,68,-42,-72,-48,-16,-26,91,127,-74,-83,-23,52,102,-31,-11,-17,-4,-15,40,88,-25,52,-28,-61, 
  /* [25][0][][] */ 41,20,43,-61,82,-62,24,5,63,60,-86,-86,-110,122,3,-37,-97,67,13,62,19,-41,-3,61,19,74,116,39,-38,127,30,-43, 
  /* [26][0][][] */ -108,-54,-3,67,2,-6,-43,25,-85,-45,-10,19,-59,-51,24,64,127,-16,95,-39,-19,91,17,-29,104,-29,-48,-52,-32,-4,-54,-54, 
  /* [27][0][][] */ -25,127,-30,-22,49,16,-63,-37,44,67,-43,-91,88,74,-9,-76,-3,100,-16,-29,-116,-39,5,36,-63,72,-4,-56,-18,-35,121,-54, 
  /* [28][0][][] */ 27,79,47,41,84,-95,-28,39,-7,127,-94,-5,-23,69,57,-80,67,120,54,43,-61,-77,58,39,-23,82,41,-58,71,41,94,49, 
  /* [29][0][][] */ -41,1,-3,-40,8,80,-19,-82,6,-59,12,5,117,-15,33,25,-39,-30,8,-17,-24,127,-103,1,40,-36,-21,20,-51,-13,-43,-21, 
  /* [30][0][][] */ -5,20,-45,-85,84,-82,-44,-42,43,-12,-43,-100,-102,98,36,5,-94,42,32,10,40,56,-55,28,97,108,80,-10,-127,126,-68,-40, 
  /* [31][0][][] */ 40,-15,36,58,37,-106,54,120,3,63,-56,0,-98,30,-17,-23,85,31,35,60,13,-63,127,29,11,-4,33,-16,64,35,46,60, 
};
const TfArray<4, int> tensor_dimension6 = { 4, { 32,1,1,32 } };
const TfArray<32, float> quant6_scale = { 32, { 0.015867669135332108, 0.010400562547147274, 0.013480456545948982, 0.0094488468021154404, 0.011681337840855122, 0.010646871291100979, 0.0089292367920279503, 0.012755826115608215, 0.01112944632768631, 0.015964997932314873, 0.018188098445534706, 0.013503064401447773, 0.011758570559322834, 0.019446128979325294, 0.0094131547957658768, 0.012294730171561241, 0.01214921846985817, 0.013858803547918797, 0.015597770921885967, 0.010562453418970108, 0.013355167582631111, 0.013909078203141689, 0.0087637333199381828, 0.013815287500619888, 0.013302408158779144, 0.008813152089715004, 0.011362286284565926, 0.011436859145760536, 0.01129587460309267, 0.012694293633103371, 0.0099748494103550911, 0.012705626897513866, } };
const TfLiteAffineQuantization quant6 = { (TfLiteFloatArray*)&quant6_scale, (TfLiteIntArray*)&g0::quant5_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data7[32] = { 6615, 428, -11840, -1475, 849, -1260, -854, 1367, -3292, -30, 5484, 5439, -1473, -7320, -1352, -332, -739, -2707, 1114, 3152, -1137, -4940, -615, 4644, -4398, -3307, -3004, -7, -3453, 7637, -270, -12276, };
const TfArray<32, float> quant7_scale = { 32, { 0.00015116250142455101, 0.00046537481830455363, 8.2607090007513762e-05, 0.00045173897524364293, 0.0002561597793828696, 0.00038127787411212921, 0.00015593174612149596, 0.00015320077363867313, 0.00016327317280229181, 0.00013740891881752759, 0.00016236241208389401, 0.00010822420881595463, 0.00040751084452494979, 0.00012325560965109617, 0.00035286173806525767, 0.0010396427242085338, 0.001007274491712451, 0.00032723176991567016, 0.00048286927631124854, 0.00014040518726687878, 0.000284982641460374, 0.0002901436819229275, 0.00016657622472848743, 0.00018263835227116942, 0.00027407720335759223, 0.00030757379136048257, 0.00027720408979803324, 0.0001162428452516906, 0.00021261446818243712, 0.00011836343765025958, 0.0017075028736144304, 7.2183385782409459e-05, } };
const TfLiteAffineQuantization quant7 = { (TfLiteFloatArray*)&quant7_scale, (TfLiteIntArray*)&g0::quant5_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data8[1*3*3*32] = { 
  /* [0][0][][] */ -58,21,114,45,53,67,91,40,114,-127,-28,-84,95,99,108,103,80,-116,-28,-127,98,111,11,-111,73,122,82,-53,59,-113,116,111, -44,48,127,50,-54,104,-34,-8,-92,-7,-45,-46,127,127,109,66,127,66,-52,7,115,100,35,-127,103,91,-71,-44,63,-74,127,89, -98,58,40,127,-127,86,-65,-36,88,45,-2,15,99,54,25,-56,108,111,-30,109,113,79,31,-19,60,60,94,88,127,-2,-42,-52, 
  /* [0][1][][] */ -60,0,31,60,53,115,65,31,-7,-82,-53,-63,99,73,127,127,61,127,-82,-83,80,109,-100,-57,118,127,76,-92,-34,-91,117,81, -75,-7,41,59,-43,123,25,-3,-127,0,-70,-127,100,77,119,68,98,120,-61,-71,85,121,19,-79,127,102,-74,-34,-56,-127,112,100, -116,-21,30,109,-31,63,-127,-127,27,34,-47,2,92,65,11,-20,68,113,-4,36,123,118,20,-32,51,73,91,61,69,-59,-27,115, 
  /* [0][2][][] */ -27,-85,52,-67,54,110,36,22,-21,-113,-10,-12,110,52,86,121,85,107,-127,-1,77,122,-127,-59,118,81,113,-127,7,-90,127,101, -89,-93,110,39,22,127,84,-9,-12,-42,-102,-106,85,110,116,81,94,127,-36,-59,103,127,3,-120,110,65,-33,-126,20,-125,113,119, -127,-127,96,73,37,76,9,-121,75,38,-127,-3,106,58,76,106,70,94,-18,58,127,43,31,-25,0,27,127,97,75,-93,-14,127, 
};
const TfArray<4, int> tensor_dimension8 = { 4, { 1,3,3,32 } };
const TfArray<32, float> quant8_scale = { 32, { 0.0062818499282002449, 0.019339550286531448, 0.0034328973852097988, 0.01877288706600666, 0.010645215399563313, 0.015844739973545074, 0.0064800451509654522, 0.0063665546476840973, 0.0067851324565708637, 0.0057102935388684273, 0.006747283972799778, 0.0044974661432206631, 0.016934901475906372, 0.0051221251487731934, 0.014663851819932461, 0.043204363435506821, 0.041859239339828491, 0.013598748482763767, 0.02006656676530838, 0.0058348090387880802, 0.011843005195260048, 0.012057481333613396, 0.0069223972968757153, 0.0075898896902799606, 0.011389808729290962, 0.012781823985278606, 0.011519752442836761, 0.0048306961543858051, 0.0088356053456664085, 0.0049188216216862202, 0.070958584547042847, 0.0029997201636433601, } };
const TfLiteAffineQuantization quant8 = { (TfLiteFloatArray*)&quant8_scale, (TfLiteIntArray*)&g0::quant5_zero, 3 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data9[32] = { 1129, -126, 793, 291, -5741, -3224, -2220, -292, -602, 3435, -2738, -4011, -9569, -2751, -879, -7557, -8349, -6398, -7859, -6570, -5900, -357, 1346, -575, 2263, -2448, -865, 3188, 782, 5001, -4223, 1542, };
const TfArray<32, float> quant9_scale = { 32, { 0.00015456507389899343, 9.3552276666741818e-05, 0.00017720616597216576, 0.00010339220898458734, 0.00012751281610690057, 0.00010736120748333633, 0.00013519724598154426, 0.00015114672714844346, 0.00015370962501037866, 0.00014535494847223163, 0.00017139401461463422, 0.00016821258759591728, 0.00010725895845098421, 0.00021738094801548868, 8.0490666732657701e-05, 0.00010420006583444774, 9.302962280344218e-05, 0.00010750952060334384, 0.00011195281695108861, 0.00016190933820325881, 0.00013194017810747027, 0.00020159124687779695, 0.00017527623276691884, 0.00017562854918651283, 0.0001658368855714798, 0.00014749050023965538, 9.4537936092820019e-05, 0.00020135045633651316, 0.0001713920064503327, 0.00016482060891576111, 8.0271376646123827e-05, 0.00017764394578989595, } };
const TfLiteAffineQuantization quant9 = { (TfLiteFloatArray*)&quant9_scale, (TfLiteIntArray*)&g0::quant5_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data10[32*1*1*24] = { 
  /* [0][0][][] */ 36,116,30,-103,-53,-39,50,-6,-2,41,-61,94,-68,64,-90,-11,77,-7,-127,-61,-7,-10,-81,31, 
  /* [1][0][][] */ -91,-21,-31,115,-16,-47,-9,51,28,106,17,66,-23,-115,-26,36,-127,-17,-37,-95,-55,1,-75,57, 
  /* [2][0][][] */ -31,25,50,89,-23,-34,9,63,62,60,-3,28,-127,-7,-56,29,9,-116,43,-27,26,14,45,-22, 
  /* [3][0][][] */ -20,-27,-56,-85,-21,28,123,33,75,38,81,-52,-12,-76,-11,-41,-30,-11,-120,-45,64,25,-127,54, 
  /* [4][0][][] */ 86,-14,-37,-18,-56,-6,-54,18,107,57,8,127,-63,78,17,51,31,-11,-86,71,23,21,28,40, 
  /* [5][0][][] */ 99,-4,-30,36,-23,-13,-55,-67,21,-54,-89,5,-64,-22,41,120,-16,100,66,-52,-127,17,50,-36, 
  /* [6][0][][] */ -50,70,94,-98,-5,94,10,-127,32,64,-48,8,16,-2,-55,-65,16,2,-53,106,91,65,-12,-41, 
  /* [7][0][][] */ 10,19,-64,-20,-52,12,24,-24,90,27,7,78,33,-38,9,13,127,109,-14,-60,-105,-35,-51,43, 
  /* [8][0][][] */ 108,70,45,19,-69,-53,-58,22,8,13,-127,18,32,75,-40,118,-48,-39,-16,-25,-23,66,115,-49, 
  /* [9][0][][] */ 26,13,68,4,22,-20,-90,-113,36,-113,112,-7,-13,-109,75,15,-63,-127,17,-28,88,-57,-2,-17, 
  /* [10][0][][] */ -22,107,113,9,-79,24,27,65,21,-16,-24,-127,21,42,-11,18,51,61,24,19,58,5,-106,-10, 
  /* [11][0][][] */ 127,-74,-10,78,48,-33,-90,-45,42,41,66,-24,10,113,-109,54,115,-75,95,31,-53,28,110,-74, 
  /* [12][0][][] */ -127,43,54,103,84,-13,-33,80,27,80,111,32,21,-51,109,-122,-101,51,40,43,7,-118,-96,14, 
  /* [13][0][][] */ 88,32,2,37,22,-114,21,21,127,-1,-100,1,-5,51,-49,-18,54,6,51,19,37,12,40,-45, 
  /* [14][0][][] */ 9,-54,59,14,-127,-16,-53,68,-8,-54,-7,-21,-44,-37,-7,73,-26,-82,98,-36,-85,-27,41,-31, 
  /* [15][0][][] */ -13,-103,-21,-80,22,-90,6,-19,-62,46,113,44,47,127,31,-6,22,52,-5,48,-12,-11,34,-88, 
  /* [16][0][][] */ -127,-52,102,24,-34,-39,-100,-22,-50,11,75,78,3,78,-17,20,21,-56,47,85,-30,-15,36,76, 
  /* [17][0][][] */ 20,-61,44,55,-127,-71,-61,98,62,103,74,-9,53,-10,-19,87,-42,21,-15,45,-11,-43,9,22, 
  /* [18][0][][] */ -88,-81,91,-4,-31,9,-60,-4,17,26,3,4,14,72,59,-41,-68,25,106,44,38,87,127,-4, 
  /* [19][0][][] */ -11,-4,84,57,25,43,4,-17,86,82,52,-7,-20,39,-13,30,-2,127,64,-13,81,77,-10,-40, 
  /* [20][0][][] */ 13,53,65,8,68,70,-32,-127,-32,87,4,-78,30,38,-64,-96,9,79,63,-25,37,-43,16,-85, 
  /* [21][0][][] */ -6,13,35,1,-37,-80,0,-103,24,-32,-26,-43,-41,12,17,46,-21,-62,33,127,-8,5,5,0, 
  /* [22][0][][] */ -127,56,29,-16,-118,17,16,-34,-18,-1,45,21,-55,37,-38,-20,85,-27,-5,37,-66,32,-75,65, 
  /* [23][0][][] */ 46,9,55,-24,53,-109,-64,-123,-53,-48,33,-75,91,-55,5,35,-26,27,-1,127,-55,-10,-37,116, 
  /* [24][0][][] */ 38,-28,23,44,-59,-103,-19,31,5,-89,-10,-23,-127,75,43,-37,39,-55,6,47,-62,39,-55,-23, 
  /* [25][0][][] */ 5,31,66,26,-10,49,34,-20,22,69,40,1,-48,-32,-20,-1,15,50,-127,-20,-15,-76,-13,-86, 
  /* [26][0][][] */ -40,2,127,77,13,-81,84,111,67,-21,-74,-117,-50,33,-32,-39,97,-104,71,-49,-30,-3,-30,-66, 
  /* [27][0][][] */ 50,22,-93,-89,-97,9,-11,-75,49,-23,-17,100,-127,-62,51,-1,31,-34,6,16,72,15,21,-15, 
  /* [28][0][][] */ -38,7,57,17,-35,44,-10,53,-127,-22,-82,27,-116,77,-60,51,25,-106,99,52,-12,34,113,-22, 
  /* [29][0][][] */ 10,-21,-47,73,-82,-29,-40,-127,-19,-105,-19,-44,23,-43,98,86,-63,-45,-30,11,51,-66,-47,98, 
  /* [30][0][][] */ 58,-116,76,18,-69,-42,-29,7,12,-127,-114,13,74,46,-116,27,-74,43,13,19,59,-87,-33,-46, 
  /* [31][0][][] */ 57,10,21,35,43,1,-75,13,10,14,-6,2,4,-35,-94,73,18,-127,5,8,-39,52,-4,58, 
};
const TfArray<4, int> tensor_dimension10 = { 4, { 32,1,1,24 } };
const TfArray<32, float> quant10_scale = { 32, { 0.0038851494900882244, 0.0023515310604125261, 0.004454256035387516, 0.0025988677516579628, 0.0032051634043455124, 0.0026986324228346348, 0.003398319473490119, 0.0037992256693542004, 0.0038636468816548586, 0.0036536434199661016, 0.0043081617914140224, 0.0042281933128833771, 0.0026960624381899834, 0.005464090034365654, 0.002023214241489768, 0.002619174076244235, 0.0023383935913443565, 0.0027023605071008205, 0.0028140472713857889, 0.0040697548538446426, 0.0033164496999233961, 0.0050671999342739582, 0.004405745305120945, 0.0044146012514829636, 0.0041684778407216072, 0.0037073227576911449, 0.0023763065692037344, 0.0050611472688615322, 0.0043081114999949932, 0.0041429325938224792, 0.0020177022088319063, 0.0044652600772678852, } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&g0::quant5_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data11[24] = { 1889, 2157, 464, -186, -1204, 5136, -1544, -2553, 1264, -3357, 3222, -3323, -3717, 5022, 2120, 540, -2815, 3222, 1082, 5423, -61, -2850, 1722, 2011, };
const TfArray<1, int> tensor_dimension11 = { 1, { 24 } };
const TfArray<24, float> quant11_scale = { 24, { 0.00038040601066313684, 0.00021408639440778643, 0.00053129758452996612, 0.0002987892075907439, 0.00025564961833879352, 0.00030909472843632102, 0.00025532202562317252, 0.00027082019369117916, 0.00042342292726971209, 0.00029710590024478734, 0.0002344483946217224, 0.00027496647089719772, 0.00026868199347518384, 0.00023582389985676855, 0.0003837615076918155, 0.00038151367334648967, 0.00025756680406630039, 0.00036575301783159375, 0.00020485087588895112, 0.00033976961276493967, 0.00035585457226261497, 0.00025637203361839056, 0.00052094424609094858, 0.00045117802801541984, } };
const TfArray<24, int> quant11_zero = { 24, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data12[1*3*3*24] = { 
  /* [0][0][][] */ 10,-35,-127,-28,-36,-52,27,-71,29,96,127,28,84,-37,-127,-54,127,-70,-127,-84,-45,12,19,37, 63,-77,7,28,37,-58,-82,10,-109,76,-103,24,120,-75,-27,59,80,-59,70,-19,-119,127,33,-81, -127,57,48,93,-39,4,92,31,-64,2,-59,25,75,-36,20,71,19,-67,69,37,96,54,3,-43, 
  /* [0][1][][] */ -112,94,-49,-110,101,-110,22,-33,-30,-63,-21,127,95,-100,14,-33,11,-127,-117,-93,86,-47,-6,127, 61,-118,-11,96,127,-32,-127,110,-89,2,-105,105,127,-91,-45,-25,52,49,65,-127,-82,72,-32,-58, -67,113,46,6,-94,-62,55,31,21,11,-26,28,-74,-46,-14,16,45,-86,53,-36,127,4,-127,-13, 
  /* [0][2][][] */ -32,60,-29,61,18,-127,39,-127,-62,127,-114,85,36,-127,-49,-70,-114,-1,-112,-27,-20,5,11,-51, 25,-127,39,42,86,-67,-37,100,24,112,-90,88,62,-44,-57,25,89,75,38,-104,21,102,-11,-38, -57,73,22,-127,-79,-83,85,30,127,47,68,-39,-63,-53,-15,-127,37,-46,20,1,103,55,-41,-26, 
};
const TfArray<4, int> tensor_dimension12 = { 4, { 1,3,3,24 } };
const TfArray<24, float> quant12_scale = { 24, { 0.0094063924625515938, 0.0052937665022909641, 0.013137525878846645, 0.0073882341384887695, 0.0063215107657015324, 0.0076430612243711948, 0.0063134101219475269, 0.0066966372542083263, 0.010470082052052021, 0.0073466100730001926, 0.0057972627691924572, 0.0067991632968187332, 0.006643765140324831, 0.0058312751352787018, 0.0094893649220466614, 0.0094337817281484604, 0.0063689174130558968, 0.0090440642088651657, 0.0050653978250920773, 0.0084015661850571632, 0.0087993033230304718, 0.0063393739983439445, 0.012881515547633171, 0.011156389489769936, } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&g0::quant11_zero, 3 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data13[24] = { 7198, -2592, 6850, -359, -3247, 2021, 810, 2372, 2880, 1460, -3082, 1346, 12231, 718, -1316, -320, -1067, 7746, -12069, 6790, 5885, 824, -715, 12073, };
const TfArray<24, float> quant13_scale = { 24, { 0.00010201510303886607, 0.00015250239812303334, 0.00011059465032303706, 0.00021331189782358706, 0.00011267661466263235, 0.00011396144691389054, 0.00017161101277451962, 0.00021427392493933439, 7.2597627877257764e-05, 0.00019896299636457115, 0.00013823444896843284, 0.00016047710960265249, 8.1557940575294197e-05, 0.00013964998652227223, 0.00013883950305171311, 0.00010993848991347477, 0.00017064131679944694, 8.7027685367502272e-05, 0.00015629801782779396, 8.5026877059135586e-05, 0.00012170812260592356, 0.00014887515862938017, 0.00013280162238515913, 7.5445852417033166e-05, } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&g0::quant11_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data14[24*1*1*16] = { 
  /* [0][0][][] */ 21,-28,-108,-127,21,23,4,22,69,-39,-65,-104,-77,63,21,40, 
  /* [1][0][][] */ 83,78,44,28,72,-6,52,-14,47,11,-44,32,-108,18,-127,-36, 
  /* [2][0][][] */ -80,35,-9,-75,20,1,11,-2,13,-23,-49,9,-70,127,-27,27, 
  /* [3][0][][] */ 24,58,-62,-17,-39,13,13,-38,4,-6,-39,86,-31,-54,127,-36, 
  /* [4][0][][] */ 100,-124,51,127,-31,-52,28,-20,76,41,33,-7,33,34,-85,40, 
  /* [5][0][][] */ -42,28,-33,126,10,10,-76,120,12,-25,-20,127,-26,-59,-18,29, 
  /* [6][0][][] */ 87,16,-11,6,-94,-9,-127,69,8,-110,66,-50,-7,71,2,10, 
  /* [7][0][][] */ -72,21,-43,127,-4,-62,-58,-67,70,19,-14,-24,7,-40,31,-64, 
  /* [8][0][][] */ 109,17,30,102,29,-31,4,27,-11,-126,54,-126,-2,-123,127,43, 
  /* [9][0][][] */ -51,42,22,0,-111,41,-127,21,97,62,-44,-13,64,54,-8,-7, 
  /* [10][0][][] */ -84,92,63,6,34,56,-80,33,75,127,-50,40,50,-5,25,-20, 
  /* [11][0][][] */ -16,-83,87,60,109,35,-57,12,-60,35,-51,7,-6,14,-127,-26, 
  /* [12][0][][] */ -127,21,-72,-54,52,54,35,-38,-93,-73,45,-19,-107,34,-51,-123, 
  /* [13][0][][] */ -125,29,-37,-1,70,-91,127,79,63,29,65,-62,-127,-60,58,-21, 
  /* [14][0][][] */ -60,19,64,90,12,87,48,19,-24,123,-35,16,6,-117,-127,-53, 
  /* [15][0][][] */ -21,-1,96,-70,-42,18,-127,40,19,110,-30,48,69,76,30,75, 
  /* [16][0][][] */ 42,42,-52,-60,-71,-30,40,-37,42,55,127,39,-34,-57,-13,0, 
  /* [17][0][][] */ -48,16,37,-39,-14,0,-86,-78,-127,21,-37,88,102,-103,115,-5, 
  /* [18][0][][] */ 103,45,127,102,-32,89,-15,38,15,36,105,106,25,51,-5,47, 
  /* [19][0][][] */ 30,11,21,66,-64,-7,34,-51,21,-41,-26,-98,-127,-43,64,-26, 
  /* [20][0][][] */ -50,-38,53,-12,29,-37,-64,-106,-109,-32,-112,-6,-65,34,127,-64, 
  /* [21][0][][] */ -45,98,-27,-127,64,-77,-21,-48,-58,124,23,11,55,6,63,-41, 
  /* [22][0][][] */ -123,34,-32,-56,7,46,60,56,42,-54,82,84,15,127,78,38, 
  /* [23][0][][] */ -60,15,-118,-38,-28,-109,-23,39,-55,-127,-78,103,-32,62,-44,-45, 
};
const TfArray<4, int> tensor_dimension14 = { 4, { 24,1,1,16 } };
const TfArray<24, float> quant14_scale = { 24, { 0.0033785221166908741, 0.0050505534745752811, 0.0036626583896577358, 0.0070644342340528965, 0.0037316086236387491, 0.0037741593550890684, 0.0056833899579942226, 0.0070962943136692047, 0.0024042781442403793, 0.0065892292186617851, 0.0045780292712152004, 0.0053146588616073132, 0.0027010245248675346, 0.0046249087899923325, 0.0045980676077306271, 0.0036409278400242329, 0.0056512756273150444, 0.002882170956581831, 0.0051762559451162815, 0.0028159082867205143, 0.0040307128801941872, 0.0049304268322885036, 0.0043981056660413742, 0.0024986052885651588, } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&g0::quant11_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data15[16] = { -5641, -3812, -1718, -1595, 3590, -3564, 1656, -4616, -5221, -5028, -627, 5421, -334, 2749, -7737, -3437, };
const TfArray<1, int> tensor_dimension15 = { 1, { 16 } };
const TfArray<16, float> quant15_scale = { 16, { 0.00014127249596640468, 0.00017883222608361393, 0.00014704358181916177, 0.00019916122255381197, 0.00010381916945334524, 0.00012893203529529274, 0.00019510751008056104, 0.00013657161616720259, 0.00017349381232634187, 0.00015201125643216074, 0.00015988477389328182, 0.00024194878642447293, 0.00019905735098291188, 0.00019282723951619118, 0.00025518349139019847, 0.00018984555208589882, } };
const TfArray<16, int> quant15_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data16[1*3*3*16] = { 
  /* [0][0][][] */ 121,-28,-59,118,12,-127,127,101,64,65,-60,-127,36,-22,28,-5, 85,39,75,27,32,89,-58,67,-55,48,36,10,-2,-117,-2,90, 18,64,-81,18,-61,116,-66,17,8,57,-3,-52,-44,30,56,36, 
  /* [0][1][][] */ 127,67,-43,-55,-127,114,95,-127,127,99,103,-54,127,-42,94,-46, 23,83,104,38,-13,30,-23,75,84,-64,57,20,-17,-127,-27,39, -8,-6,-1,11,-79,4,-41,85,-9,76,-89,48,-48,108,127,14, 
  /* [0][2][][] */ 44,-62,88,-127,-110,41,33,76,58,127,127,-57,0,-53,17,8, 8,126,79,71,122,-65,-20,79,65,-33,-31,-94,-50,41,-24,122, 44,-127,127,17,-82,-104,-49,8,-31,-62,-52,31,50,31,26,127, 
};
const TfArray<4, int> tensor_dimension16 = { 4, { 1,3,3,16 } };
const TfArray<16, float> quant16_scale = { 16, { 0.0072553097270429134, 0.0091842589899897575, 0.0075516942888498306, 0.01022829208523035, 0.0053318249993026257, 0.0066215423867106438, 0.010020106099545956, 0.007013887632638216, 0.0089100953191518784, 0.0078068189322948456, 0.0082111777737736702, 0.012425726279616356, 0.010222957469522953, 0.0099029988050460815, 0.013105419464409351, 0.0097498688846826553, } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&g0::quant15_zero, 3 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data17[16] = { 2389, 2953, -895, 2004, 1499, 402, 4958, -273, 3395, -839, 1980, 7504, 1235, 3978, 10507, -902, };
const TfArray<16, float> quant17_scale = { 16, { 0.00013219038373790681, 0.00011583535524550825, 0.00015134303248487413, 0.00011299131438136101, 0.00013883081555832177, 0.00016824093472678214, 8.4400242485571653e-05, 0.00018684964743442833, 9.4694551080465317e-05, 0.00013561722880695015, 0.00016029861581046134, 6.0864655097248033e-05, 0.00015802406414877623, 9.5821909781079739e-05, 5.047289960202761e-05, 0.00015181022172328085, } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&g0::quant15_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data18[16*3*3*1] = { 
  /* [0][0][][] */ -8, -35, -36, 
  /* [0][1][][] */ 25, -121, -7, 
  /* [0][2][][] */ 20, -127, 9, 
  /* [1][0][][] */ -70, -25, -127, 
  /* [1][1][][] */ -28, 36, -119, 
  /* [1][2][][] */ 43, 93, -25, 
  /* [2][0][][] */ 32, -108, -69, 
  /* [2][1][][] */ 62, -127, -49, 
  /* [2][2][][] */ 26, -35, 35, 
  /* [3][0][][] */ -25, 44, 58, 
  /* [3][1][][] */ 127, 89, 105, 
  /* [3][2][][] */ 89, 67, 76, 
  /* [4][0][][] */ 7, -57, -13, 
  /* [4][1][][] */ 72, -47, -39, 
  /* [4][2][][] */ 127, -12, -111, 
  /* [5][0][][] */ -24, -26, 15, 
  /* [5][1][][] */ -67, -22, -89, 
  /* [5][2][][] */ -39, 53, -127, 
  /* [6][0][][] */ -58, -99, -25, 
  /* [6][1][][] */ -86, -109, -78, 
  /* [6][2][][] */ -17, -49, -127, 
  /* [7][0][][] */ 83, 127, 4, 
  /* [7][1][][] */ -13, -36, 60, 
  /* [7][2][][] */ -30, -80, -89, 
  /* [8][0][][] */ 87, 43, -45, 
  /* [8][1][][] */ 85, -30, -118, 
  /* [8][2][][] */ 65, -127, -110, 
  /* [9][0][][] */ -47, 127, 43, 
  /* [9][1][][] */ 2, 125, 47, 
  /* [9][2][][] */ 36, 42, 47, 
  /* [10][0][][] */ 60, -21, 0, 
  /* [10][1][][] */ 38, 5, -127, 
  /* [10][2][][] */ -40, 31, -118, 
  /* [11][0][][] */ 64, -31, -34, 
  /* [11][1][][] */ 3, -127, -77, 
  /* [11][2][][] */ 0, -84, -64, 
  /* [12][0][][] */ 11, 75, 26, 
  /* [12][1][][] */ 69, 127, 28, 
  /* [12][2][][] */ 49, 30, -33, 
  /* [13][0][][] */ 17, 109, 8, 
  /* [13][1][][] */ 73, 127, -1, 
  /* [13][2][][] */ 26, 50, -22, 
  /* [14][0][][] */ -25, -112, 2, 
  /* [14][1][][] */ -127, -110, 89, 
  /* [14][2][][] */ -97, 3, 104, 
  /* [15][0][][] */ 84, 11, 42, 
  /* [15][1][][] */ 31, -22, -127, 
  /* [15][2][][] */ -76, -4, 85, 
};
const TfArray<4, int> tensor_dimension18 = { 4, { 16,3,3,1 } };
const TfArray<16, float> quant18_scale = { 16, { 0.002956839744001627, 0.0025910099502652884, 0.0033852469641715288, 0.0025273943319916725, 0.0031053733546286821, 0.003763220040127635, 0.0018878680421039462, 0.0041794604621827602, 0.0021181316114962101, 0.003033491550013423, 0.0035855658352375031, 0.0013614230556413531, 0.0035346888471394777, 0.0021433483343571424, 0.0011289798421785235, 0.0033956971019506454, } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&g0::quant15_zero, 0 };
const TfArray<4, int> tensor_dimension19 = { 4, { 1,49,13,1 } };
const TfArray<4, int> tensor_dimension20 = { 4, { 1,25,7,16 } };
const TfArray<1, float> quant20_scale = { 1, { 0.019471600651741028, } };
const TfArray<1, int> quant20_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<1, float> quant21_scale = { 1, { 0.030195185914635658, } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<4, int> tensor_dimension22 = { 4, { 1,25,7,24 } };
const TfArray<1, float> quant22_scale = { 1, { 0.040441222488880157, } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<4, int> tensor_dimension23 = { 4, { 1,13,4,24 } };
const TfArray<1, float> quant23_scale = { 1, { 0.039783559739589691, } };
const TfLiteAffineQuantization quant23 = { (TfLiteFloatArray*)&quant23_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<4, int> tensor_dimension24 = { 4, { 1,13,4,32 } };
const TfArray<1, float> quant24_scale = { 1, { 0.024063372984528542, } };
const TfLiteAffineQuantization quant24 = { (TfLiteFloatArray*)&quant24_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<1, float> quant25_scale = { 1, { 0.051810599863529205, } };
const TfLiteAffineQuantization quant25 = { (TfLiteFloatArray*)&quant25_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<1, float> quant26_scale = { 1, { 0.11186974495649338, } };
const TfLiteAffineQuantization quant26 = { (TfLiteFloatArray*)&quant26_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<2, int> tensor_dimension27 = { 2, { 1,32 } };
const TfArray<1, float> quant27_scale = { 1, { 0.017638819292187691, } };
const TfLiteAffineQuantization quant27 = { (TfLiteFloatArray*)&quant27_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfArray<2, int> tensor_dimension28 = { 2, { 1,7 } };
const TfArray<1, float> quant28_scale = { 1, { 0.1689283549785614, } };
const TfArray<1, int> quant28_zero = { 1, { 33 } };
const TfLiteAffineQuantization quant28 = { (TfLiteFloatArray*)&quant28_scale, (TfLiteIntArray*)&quant28_zero, 0 };
const TfArray<1, float> quant29_scale = { 1, { 0.00390625, } };
const TfLiteAffineQuantization quant29 = { (TfLiteFloatArray*)&quant29_scale, (TfLiteIntArray*)&g0::quant20_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 19 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 2,2, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 19,18,17 } };
const TfArray<1, int> outputs1 = { 1, { 20 } };
const TfLiteDepthwiseConvParams opdata2 = { kTfLitePaddingSame, 1,1, 1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs2 = { 3, { 20,16,15 } };
const TfArray<1, int> outputs2 = { 1, { 21 } };
const TfLiteConvParams opdata3 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs3 = { 3, { 21,14,13 } };
const TfArray<1, int> outputs3 = { 1, { 22 } };
const TfLiteDepthwiseConvParams opdata4 = { kTfLitePaddingSame, 2,2, 1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs4 = { 3, { 22,12,11 } };
const TfArray<1, int> outputs4 = { 1, { 23 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 23,10,9 } };
const TfArray<1, int> outputs5 = { 1, { 24 } };
const TfLiteDepthwiseConvParams opdata6 = { kTfLitePaddingSame, 1,1, 1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs6 = { 3, { 24,8,7 } };
const TfArray<1, int> outputs6 = { 1, { 25 } };
const TfLiteConvParams opdata7 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs7 = { 3, { 25,6,5 } };
const TfArray<1, int> outputs7 = { 1, { 26 } };
const ALIGN(1) uint8_t opdata8[1] = { 0,  }; /* op type 40=MEAN */
const TfArray<2, int> inputs8 = { 2, { 26,2 } };
const TfArray<1, int> outputs8 = { 1, { 27 } };
const TfLiteFullyConnectedParams opdata9 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs9 = { 3, { 27,4,3 } };
const TfArray<1, int> outputs9 = { 1, { 28 } };
const TfLiteSoftmaxParams opdata10 = { 1 };
const TfArray<1, int> inputs10 = { 1, { 28 } };
const TfArray<1, int> outputs10 = { 1, { 29 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension0, 637, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant0))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 8, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 28, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant3))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 224, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant4))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 128, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant5))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 1024, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant6))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data7, (TfLiteIntArray*)&g0::tensor_dimension5, 128, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant7))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data8, (TfLiteIntArray*)&g0::tensor_dimension8, 288, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant8))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data9, (TfLiteIntArray*)&g0::tensor_dimension5, 128, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant9))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data10, (TfLiteIntArray*)&g0::tensor_dimension10, 768, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant10))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data11, (TfLiteIntArray*)&g0::tensor_dimension11, 96, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant11))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data12, (TfLiteIntArray*)&g0::tensor_dimension12, 216, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant12))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data13, (TfLiteIntArray*)&g0::tensor_dimension11, 96, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant13))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data14, (TfLiteIntArray*)&g0::tensor_dimension14, 384, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant14))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data15, (TfLiteIntArray*)&g0::tensor_dimension15, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant15))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data16, (TfLiteIntArray*)&g0::tensor_dimension16, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant16))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data17, (TfLiteIntArray*)&g0::tensor_dimension15, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant17))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data18, (TfLiteIntArray*)&g0::tensor_dimension18, 144, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant18))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 2800), (TfLiteIntArray*)&g0::tensor_dimension19, 637, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant0))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension20, 2800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant20))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 4208), (TfLiteIntArray*)&g0::tensor_dimension20, 2800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant21))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension22, 4200, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant22))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 4208), (TfLiteIntArray*)&g0::tensor_dimension23, 1248, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant23))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension24, 1664, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant24))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1664), (TfLiteIntArray*)&g0::tensor_dimension24, 1664, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant25))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension24, 1664, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant26))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1792), (TfLiteIntArray*)&g0::tensor_dimension27, 32, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant27))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 16), (TfLiteIntArray*)&g0::tensor_dimension28, 7, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant28))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension28, 7, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant29))}, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[11] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[11] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_RESHAPE, OP_CONV_2D, OP_DEPTHWISE_CONV_2D, OP_CONV_2D, OP_DEPTHWISE_CONV_2D, OP_CONV_2D, OP_DEPTHWISE_CONV_2D, OP_CONV_2D, OP_MEAN, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 30, };
const size_t tflNodes_subgraph_index[] = {0, 11, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  29, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = tensorData[i].type;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization = tensorData[i].quantization;
  if (tensor->quantization.type == kTfLiteAffineQuantization) {
    TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
    tensor->params.scale = quant->scale->data[0];
    tensor->params.zero_point = quant->zero_point->data[0];
  }

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = tensorData[i].type;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_822117_6_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 30;
  for (size_t i = 0; i < 30; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_DEPTHWISE_CONV_2D] = Register_DEPTHWISE_CONV_2D();
  registrations[OP_MEAN] = Register_MEAN();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_822117_6_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_822117_6_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_822117_6_invoke() {
  for (size_t i = 0; i < 11; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_822117_6_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
